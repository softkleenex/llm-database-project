# 

 1-3)의 쿼리는, 과제 문서에 있는 10개 타입을 타입별로 각각 하나씩 작성해주시고, 

```python
-- ============================================
-- Phase 2 SQL Queries - 상재 담당
-- ============================================
-- 담당 엔티티: MODEL, MODEL_CONFIG, DEPLOYMENTS, DATASET, PROMPT_TEMPLATE
-- 총 10개 Query Type 작성
-- ============================================

-- ============================================
-- Type 1: Single-table query (Selection + Projection)
-- ============================================
-- 설명: 활성 상태인 프로덕션 배포 환경의 서버명과 GPU 개수 조회
-- 목적: 현재 운영중인 프로덕션 서버 리소스 파악

SELECT server_name, gpu_count, environment, status
FROM DEPLOYMENTS
WHERE environment = '프로덕션'
  AND status = '활성';

-- ============================================
-- Type 2: Multi-way join with join predicates in WHERE
-- ============================================
-- 설명: 각 모델이 어떤 데이터셋으로 어느 환경에 배포되었는지 조회
-- 목적: 모델-데이터셋-배포 환경의 전체 매핑 관계 파악

SELECT
    M.model_name AS model_name,
    M.model_type AS model_type,
    D.server_name AS server_name,
    D.environment AS environment,
    DS.learning_type AS dataset_learning_type,
    DS.s3_path AS dataset_path
FROM MODEL M, DEPLOYMENTS D, DATASET DS
WHERE M.model_id = D.model_id
  AND D.dataset_id = DS.dataset_id;

-- ============================================
-- Type 3: Aggregation + multi-way join + GROUP BY
-- ============================================
-- 설명: 각 모델별로 설정 개수, 배포 개수를 집계
-- 목적: 모델별 활용도 및 설정 다양성 분석

SELECT
    M.model_name,
    M.model_type,
    COUNT(DISTINCT MC.config_id) AS config_count,
    COUNT(DISTINCT D.deployment_id) AS deployment_count
FROM MODEL M, MODEL_CONFIG MC, DEPLOYMENTS D
WHERE M.model_id = MC.model_id
  AND M.model_id = D.model_id
GROUP BY M.model_name, M.model_type;

-- ============================================
-- Type 4: Subquery
-- ============================================
-- 설명: 평균보다 많은 GPU를 사용하는 배포 환경 조회
-- 목적: 고사양 배포 환경 식별 및 리소스 최적화

SELECT
    deployment_id,
    server_name,
    gpu_count,
    environment
FROM DEPLOYMENTS
WHERE gpu_count > (
    SELECT AVG(gpu_count)
    FROM DEPLOYMENTS
);

-- ============================================
-- Type 5: EXISTS를 포함하는 Subquery
-- ============================================
-- 설명: 실제로 배포에 사용된 적이 있는 데이터셋만 조회
-- 목적: 활용되고 있는 데이터셋 파악 (사용되지 않는 데이터셋 제외)

SELECT
    dataset_id,
    learning_type,
    description,
    created_at
FROM DATASET DS
WHERE EXISTS (
    SELECT 1
    FROM DEPLOYMENTS D
    WHERE D.dataset_id = DS.dataset_id
);

-- ============================================
-- Type 6: Selection + Projection + IN predicates
-- ============================================
-- 설명: 특정 작업 카테고리(요약, 번역, 코딩)에 해당하는 프롬프트 템플릿 조회
-- 목적: 주요 작업 유형별 템플릿 목록 확인

SELECT
    template_name,
    task_category,
    version,
    usage_count
FROM PROMPT_TEMPLATE
WHERE task_category IN ('요약', '번역', '코딩')
ORDER BY usage_count DESC;

-- ============================================
-- Type 7: In-line view를 활용한 Query
-- ============================================
-- 설명: 모델별 평균 temperature 설정값과 해당 모델의 배포 개수 조회
-- 목적: 모델별 설정 경향과 활용도 동시 분석

SELECT
    M.model_name,
    AVG_CONFIG.avg_temperature,
    AVG_CONFIG.config_count,
    DEPLOY_COUNT.deployment_count
FROM MODEL M,
    (SELECT
        model_id,
        AVG(temperature) AS avg_temperature,
        COUNT(*) AS config_count
     FROM MODEL_CONFIG
     GROUP BY model_id) AVG_CONFIG,
    (SELECT
        model_id,
        COUNT(*) AS deployment_count
     FROM DEPLOYMENTS
     GROUP BY model_id) DEPLOY_COUNT
WHERE M.model_id = AVG_CONFIG.model_id
  AND M.model_id = DEPLOY_COUNT.model_id;

-- ============================================
-- Type 8: Multi-way join + ORDER BY
-- ============================================
-- 설명: 모델-설정-배포 관계를 조회하고 GPU 수 기준 내림차순 정렬
-- 목적: 고사양 배포부터 순서대로 모델 설정 정보 파악

SELECT
    M.model_name,
    MC.config_name,
    MC.max_tokens,
    MC.temperature,
    D.server_name,
    D.gpu_count,
    D.environment
FROM MODEL M, MODEL_CONFIG MC, DEPLOYMENTS D
WHERE M.model_id = MC.model_id
  AND M.model_id = D.model_id
ORDER BY D.gpu_count DESC, M.model_name ASC;

-- ============================================
-- Type 9: Aggregation + multi-way join + GROUP BY + ORDER BY
-- ============================================
-- 설명: 환경별(개발/테스트/프로덕션) 평균 GPU 수와 배포 개수 집계 후 정렬
-- 목적: 환경별 리소스 사용량 분석 및 비교

SELECT
    D.environment,
    COUNT(DISTINCT D.deployment_id) AS deployment_count,
    AVG(D.gpu_count) AS avg_gpu_count,
    COUNT(DISTINCT M.model_id) AS unique_models
FROM DEPLOYMENTS D, MODEL M
WHERE D.model_id = M.model_id
GROUP BY D.environment
ORDER BY avg_gpu_count DESC;

-- ============================================
-- Type 10: SET operation (MINUS)
-- ============================================
-- 설명: 전체 모델 중 아직 배포되지 않은 모델 조회
-- 목적: 등록은 되었지만 실제 사용되지 않는 모델 식별

SELECT
    model_id,
    model_name,
    model_type
FROM MODEL
MINUS
SELECT
    M.model_id,
    M.model_name,
    M.model_type
FROM MODEL M, DEPLOYMENTS D
WHERE M.model_id = D.model_id;

-- ============================================
-- 추가 Query 예시 (필요시 사용)
-- ============================================

-- [추가 1] 사용 횟수가 가장 많은 상위 5개 프롬프트 템플릿
SELECT
    template_name,
    task_category,
    usage_count,
    version
FROM PROMPT_TEMPLATE
WHERE ROWNUM <= 5
ORDER BY usage_count DESC;

-- [추가 2] 각 데이터셋이 몇 개의 배포에 사용되었는지 집계
SELECT
    DS.dataset_id,
    DS.learning_type,
    COUNT(D.deployment_id) AS used_in_deployments
FROM DATASET DS
LEFT JOIN DEPLOYMENTS D ON DS.dataset_id = D.dataset_id
GROUP BY DS.dataset_id, DS.learning_type
HAVING COUNT(D.deployment_id) > 0;

-- [추가 3] 모델별 최고/최저 temperature 설정값
SELECT
    M.model_name,
    MAX(MC.temperature) AS max_temp,
    MIN(MC.temperature) AS min_temp,
    AVG(MC.temperature) AS avg_temp
FROM MODEL M, MODEL_CONFIG MC
WHERE M.model_id = MC.model_id
GROUP BY M.model_name;

-- ============================================
-- 작성일: 2025-10-13
-- 작성자: 이상재
-- ============================================
```

2)번 etr mapping은 prompt_template, model, model_config, deployments, dataset에 대해서 작성해주시면 될 것 같아요.

```python
# ETR (Entity-to-Relation) Mapping - 상재 담당 부분

## 담당 엔티티: MODEL, MODEL_CONFIG, DEPLOYMENTS, DATASET, PROMPT_TEMPLATE

================================================================================
## 1. MODEL (LLM 모델)
================================================================================

### ER Schema
- **엔티티 타입**: Strong Entity
- **속성**:
  * model_id (PK) - 모델 고유 식별자
  * model_name - 모델명
  * model_type - 모델 유형

- **관계**:
  * MODEL_CONFIG와 1:N 관계 (HAS_CONFIG)
    - 한 모델이 여러 설정을 가질 수 있음
    - MODEL이 1, MODEL_CONFIG가 N
  * DEPLOYMENTS와 1:N 관계 (DEPLOYED_AS)
    - 한 모델이 여러 환경에 배포될 수 있음
    - MODEL이 1, DEPLOYMENTS가 N

### Relational Schema 매핑
```sql
CREATE TABLE MODEL (
    model_id VARCHAR2(50) PRIMARY KEY,
    model_name VARCHAR2(200) NOT NULL,
    model_type VARCHAR2(100) NOT NULL
);
```

### 매핑 설명
1. Strong Entity이므로 독립적인 테이블로 생성
2. model_id를 Primary Key로 설정
3. 1:N 관계는 N쪽(MODEL_CONFIG, DEPLOYMENTS)에 Foreign Key로 구현
4. 모든 속성은 NOT NULL (필수 정보)

================================================================================
## 2. MODEL_CONFIG (모델 설정)
================================================================================

### ER Schema
- **엔티티 타입**: Strong Entity
- **속성**:
  * config_id (PK) - 설정 고유 식별자
  * config_name - 설정명
  * max_tokens - 최대 토큰 수
  * temperature - 온도 파라미터
  * top_p - Top-p 샘플링
  * top_k - Top-k 샘플링
  * created_at - 생성 시간

- **관계**:
  * MODEL과 N:1 관계 (HAS_CONFIG)
    - 여러 설정이 하나의 모델에 속함
    - MODEL_CONFIG가 N, MODEL이 1
  * SESSION_LOGS와 1:N 관계 (APPLIES_CONFIG)
    - 하나의 설정이 여러 로그에서 사용됨

### Relational Schema 매핑
```sql
CREATE TABLE MODEL_CONFIG (
    config_id VARCHAR2(50) PRIMARY KEY,
    config_name VARCHAR2(200) NOT NULL,
    max_tokens NUMBER(10) NOT NULL,
    temperature NUMBER(3,2) CHECK (temperature BETWEEN 0 AND 2),
    top_p NUMBER(3,2) CHECK (top_p BETWEEN 0 AND 1),
    top_k NUMBER(10),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    model_id VARCHAR2(50) NOT NULL,
    CONSTRAINT fk_config_model FOREIGN KEY (model_id)
        REFERENCES MODEL(model_id)
);
```

### 매핑 설명
1. Strong Entity이므로 독립적인 테이블로 생성
2. config_id를 Primary Key로 설정
3. N:1 관계 구현: model_id를 Foreign Key로 추가 (NOT NULL)
4. CHECK 제약조건으로 파라미터 범위 제한
   - temperature: 0~2 범위
   - top_p: 0~1 범위
5. created_at은 DEFAULT로 현재 시간 자동 설정

================================================================================
## 3. DEPLOYMENTS (배포 환경)
================================================================================

### ER Schema
- **엔티티 타입**: Strong Entity
- **속성**:
  * deployment_id (PK) - 배포 고유 식별자
  * server_name - 서버명
  * gpu_count - GPU 개수
  * environment - 배포 환경
  * status - 배포 상태

- **관계**:
  * MODEL과 N:1 관계 (DEPLOYED_AS)
    - 여러 배포가 하나의 모델을 기반으로 함
    - DEPLOYMENTS가 N, MODEL이 1
    - Total Participation: 모든 배포는 반드시 모델 필요
  * DATASET과 N:1 관계 (USES_DATA)
    - 여러 배포가 하나의 데이터셋 사용 가능
    - Partial Participation: 데이터셋 없이도 배포 가능
  * SESSION_LOGS와 1:N 관계 (DEPLOYED_IN)
    - 하나의 배포 환경에서 여러 로그 생성

### Relational Schema 매핑
```sql
CREATE TABLE DEPLOYMENTS (
    deployment_id VARCHAR2(50) PRIMARY KEY,
    server_name VARCHAR2(200) NOT NULL,
    gpu_count NUMBER(5) NOT NULL,
    environment VARCHAR2(50) NOT NULL,
    status VARCHAR2(50) NOT NULL,
    model_id VARCHAR2(50) NOT NULL,
    dataset_id VARCHAR2(50),
    CONSTRAINT fk_deploy_model FOREIGN KEY (model_id)
        REFERENCES MODEL(model_id),
    CONSTRAINT fk_deploy_dataset FOREIGN KEY (dataset_id)
        REFERENCES DATASET(dataset_id)
);
```

### 매핑 설명
1. Strong Entity이므로 독립적인 테이블로 생성
2. deployment_id를 Primary Key로 설정
3. N:1 관계 구현:
   - model_id: NOT NULL (Total Participation)
   - dataset_id: NULL 가능 (Partial Participation - 학습 없는 배포 허용)
4. 두 개의 Foreign Key를 통해 다중 관계 표현

================================================================================
## 4. DATASET (데이터셋)
================================================================================

### ER Schema
- **엔티티 타입**: Strong Entity
- **속성**:
  * dataset_id (PK) - 데이터셋 고유 식별자
  * learning_type - 학습 유형
  * description - 데이터셋 설명
  * s3_path - S3 저장 경로
  * created_at - 생성 시간

- **관계**:
  * DEPLOYMENTS와 1:N 관계 (USES_DATA)
    - 하나의 데이터셋이 여러 배포에 사용될 수 있음
    - DATASET이 1, DEPLOYMENTS가 N
    - Partial Participation: 데이터셋이 배포에 안 쓰일 수도 있음

### Relational Schema 매핑
```sql
CREATE TABLE DATASET (
    dataset_id VARCHAR2(50) PRIMARY KEY,
    learning_type VARCHAR2(100) NOT NULL,
    description CLOB,
    s3_path VARCHAR2(500) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);
```

### 매핑 설명
1. Strong Entity이므로 독립적인 테이블로 생성
2. dataset_id를 Primary Key로 설정
3. 1:N 관계는 N쪽(DEPLOYMENTS)에 Foreign Key로 구현
4. description은 CLOB (대용량 텍스트 허용)
5. created_at은 DEFAULT로 현재 시간 자동 설정

================================================================================
## 5. PROMPT_TEMPLATE (프롬프트 템플릿)
================================================================================

### ER Schema
- **엔티티 타입**: Strong Entity
- **속성**:
  * template_id (PK) - 템플릿 고유 식별자
  * template_name - 템플릿명
  * prompt_s3_path - 프롬프트 S3 경로
  * description - 템플릿 설명
  * task_category - 작업 카테고리
  * variables - 템플릿 변수
  * version - 버전
  * usage_count - 사용 횟수
  * created_at - 생성 시간

- **관계**:
  * USER와 N:1 관계 (CREATES_TEPL)
    - 여러 템플릿이 한 사용자에 의해 생성됨
    - PROMPT_TEMPLATE이 N, USER가 1
    - Total Participation: 모든 템플릿은 반드시 생성자 있음

### Relational Schema 매핑
```sql
CREATE TABLE PROMPT_TEMPLATE (
    template_id VARCHAR2(50) PRIMARY KEY,
    template_name VARCHAR2(200) NOT NULL,
    prompt_s3_path VARCHAR2(500) NOT NULL,
    description CLOB,
    task_category VARCHAR2(100) NOT NULL,
    variables VARCHAR2(1000),
    version VARCHAR2(20) NOT NULL,
    usage_count NUMBER(10) DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    creator_user_id VARCHAR2(50) NOT NULL,
    CONSTRAINT fk_template_user FOREIGN KEY (creator_user_id)
        REFERENCES "USER"(user_id)
);
```

### 매핑 설명
1. Strong Entity이므로 독립적인 테이블로 생성
2. template_id를 Primary Key로 설정
3. N:1 관계 구현: creator_user_id를 Foreign Key로 추가 (NOT NULL)
4. usage_count는 DEFAULT 0으로 초기화
5. created_at은 DEFAULT로 현재 시간 자동 설정
6. description은 CLOB (긴 설명 허용)

================================================================================
## 관계 간 연결 매핑 요약
================================================================================

### 내부 관계 (상재 담당 엔티티 간)
1. **MODEL → MODEL_CONFIG** (1:N, HAS_CONFIG)
   - MODEL_CONFIG.model_id → MODEL.model_id (FK, NOT NULL)

2. **MODEL → DEPLOYMENTS** (1:N, DEPLOYED_AS)
   - DEPLOYMENTS.model_id → MODEL.model_id (FK, NOT NULL)

3. **DATASET → DEPLOYMENTS** (1:N, USES_DATA)
   - DEPLOYMENTS.dataset_id → DATASET.dataset_id (FK, NULL 가능)

### 외부 관계 (다른 팀원 엔티티와 연결)
4. **USER → PROMPT_TEMPLATE** (1:N, CREATES_TEPL)
   - PROMPT_TEMPLATE.creator_user_id → USER.user_id (FK, NOT NULL)
   - 영진님 담당 USER 엔티티와 연결

5. **MODEL_CONFIG → SESSION_LOGS** (1:N, APPLIES_CONFIG)
   - SESSION_LOGS.config_id → MODEL_CONFIG.config_id (FK, NULL 가능)
   - 영진님 담당 SESSION_LOGS 엔티티와 연결

6. **DEPLOYMENTS → SESSION_LOGS** (1:N, DEPLOYED_IN)
   - SESSION_LOGS.deployment_id → DEPLOYMENTS.deployment_id (FK, NOT NULL)
   - 영진님 담당 SESSION_LOGS 엔티티와 연결

================================================================================
## ER Schema 수정사항
================================================================================

### 수정 없음
- Phase 1에서 작성한 ER Schema를 그대로 Relational Schema로 매핑
- 모든 엔티티와 관계가 정규화된 형태로 올바르게 매핑됨
- 데이터 무결성을 위한 제약조건 추가 (CHECK, DEFAULT)

================================================================================
작성일: 2025-10-13
작성자: 이상재
================================================================================
```